<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>ForWinR.utf8.md</title>

<script src="ForWinR_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="ForWinR_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="ForWinR_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="ForWinR_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="ForWinR_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="ForWinR_files/navigation-1.1/tabsets.js"></script>
<link href="ForWinR_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="ForWinR_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">




</div>


<!-- # bookdown::html_document2: -->
<!-- # bookdown::pdf_document2: -->
<div id="implementacion-de-indicadores" class="section level1">
<h1>Implementación de indicadores <img src="logo/logo.png" align="right" /></h1>
<p><a href="https://www.tidyverse.org/lifecycle/#stable"><img src="https://img.shields.io/badge/lifecycle-experimental-orange.svg" alt="Life cycle" /></a> <img src="https://codecov.io/gh/tidyverse/magrittr/branch/master/graph/badge.svg" alt="Codecov test coverage" /></p>
<!---
[![Buil Status](https://travis-ci.org/tidyverse/purrr.svg?branch=master)](https://travis-ci.org/tidyverse/purrr)
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/tidyverse/purrr?branch=master&svg=true)](https://ci.appveyor.com/project/tidyverse/purrr)
[![Coverage Status](https://img.shields.io/codecov/c/github/tidyverse/purrr/master.svg)](https://codecov.io/github/tidyverse/purrr?branch=master)
-->
<div id="sinopsis" class="section level2">
<h2>Sinopsis</h2>
<p>Es una breve descripción del flujo de las funciones para realizar backtesting a partir de una estrategia. Y el uso de este para implementación de distintas estrategias de trading.</p>
<div id="estrategia" class="section level3">
<h3>Estrategia</h3>
<p>Se considera una estrategia como una combinación de indicadores y reglas para generar señales para entrar y salir de transacciones. La idea detrás de esto se presenta en la siguiente gráfica:</p>
<div style="text-align: center">
<p><img src="estrategia.png" align="center" /></p>
</div>
<p>Esto permite realizar distintas modificaciones a la estrategia:</p>
<ul>
<li><p>Si se desea realizar una estrategia con mas de una combinación indicador-señal. Se puede generar varias señales (con la función <em>Indicador_señal(.)</em>) y luego con alguna función ( <em>mix_señal(.)</em>) combinarlas para convertirla en una señal.</p></li>
<li><p>A partir de la señal generada se utiliza la función <em>orden(.)</em> la cual puede variar. Por ejemplo: puede ser ordenes normales, ordenes con stop loss, ordenes con stop loss movil, dependiendo de la que quede mejor con la estrategia. (Nota: no todas les funciona el mismo sistema de ordenes, por ejemplo, bandas de bollinger no funciona muy bien con un stop loss movil ya que es un indicador para identificar señales en rango (choppy market) es mejor un stop loss fijo, funcionando como una especie de support)</p></li>
<li><p>Y por ultimo, la salida de la función <em>orden(.)</em> se pasa por transacciones, la cuál computa el backtesting de la estrategia.</p></li>
</ul>
<p>Algo importante para notar en este caso es que las tres funciones principales <em>Indicador_señal(.)</em>, <em>orden(.)</em> y <em>transacciones(.)</em> necesitan de los datos, esto permite poder utilizar en cada paso información diferente de los datos, es claro que en el calculo de un indicador se utiliza diferente información, al igual que la función de <em>orden(.)</em> que por construcción puede utilizar cualquier información de los datos, por ejemplo el stop loss movil utiliza el promedio movil ponderado de los close para ir moviendo el valor del stop movil en vez de tomar la serie del close ya que esta esta es mas volátil.</p>
</div>
</div>
<div id="tabla-de-especificaciones-basicas-tbl.specs" class="section level2">
<h2>Tabla de especificaciones básicas <code>tbl.specs</code></h2>
<p>En esta tabla se encuentra las especificaciones esenciales para poder programar la estrategia. En ella se encuentra lo siguiente:</p>
<ul>
<li><strong>nameInd</strong> := Nombre corto y único para llamar la estrategia.</li>
<li><strong>f</strong> := Nombre de la función que calcula los indicadores.</li>
<li><strong>dat.f</strong> := Nombre de la función que selecciona los datos, los cuales entrar como argumento principal a la función <strong>f</strong>.</li>
<li><strong>sig.f</strong> := Nombre de la función que calcula las señales a partir de la salida de <strong>f</strong>.</li>
<li><strong>parms</strong> := Parámetros para el calculo del indicador, en forma de lista.</li>
<li><strong>sig.parms</strong> := Parámetros para el calculo de la señal, en forma de lista.</li>
</ul>
<pre class="r"><code>tbl.specs &lt;- tribble(
  ~nameInd, ~f, ~dat.f, ~sig.f, ~parms, ~sig.parms,
  &#39;adx&#39;, &#39;ADX&#39;, &#39;hlc&#39;, &#39;sig.ADXL&#39;, list(), list(limit = 25),
  &#39;smaTwo&#39;, &#39;SMAtwo&#39;, &#39;cl&#39;, &#39;sig.SMAtwo&#39;, list(nfast = 30, nslow = 100), list(),
  &#39;bands&#39;, &#39;BBands&#39;, &#39;hlc&#39;, &#39;sig.BBands&#39;, list(), list()
)

tbl.specs</code></pre>
<pre><code>## # A tibble: 3 x 6
##   nameInd f      dat.f sig.f      parms      sig.parms 
##   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;      &lt;list&gt;     &lt;list&gt;    
## 1 adx     ADX    hlc   sig.ADXL   &lt;list [0]&gt; &lt;list [1]&gt;
## 2 smaTwo  SMAtwo cl    sig.SMAtwo &lt;list [2]&gt; &lt;list [0]&gt;
## 3 bands   BBands hlc   sig.BBands &lt;list [0]&gt; &lt;list [0]&gt;</code></pre>
<p>Por el momento son muchas cosas para determinar, pero esto facilita la forma de poder usarlas en la forma actual del código. Si en las columnas <strong>parms</strong> y <strong>sig.parms</strong> se dejan listas vacías, el toma los parámetros que tiene por defecto las funciones <strong>f</strong> y <strong>sig.f</strong> o pueden variar al antojo (para hacer tunning de la estrategia).</p>
<div class="customBlock">
<p><strong>NOTA:</strong> Es importante que los nombres de las funciones en la tabla <code>tbl.specs</code> estén cargadas antes de proseguir. La mayoría de funciones para calcular indicadores salen del paquete <code>TTR</code>, por lo tanto es necesario siempre tener cargado este paquete.</p>
</div>
</div>
<div id="indseg.-la-funcion-indicador_senal." class="section level2">
<h2><code>indSeg(.)</code> la función <em>Indicador_señal(.)</em></h2>
<p>Esta función genera un vector con las señales producto de un indicador, cuenta con los siguiente parámetros.</p>
<pre class="r"><code>args(indSeg)</code></pre>
<pre><code>## function (parm = NULL, sigParm = NULL, datos, indName) 
## NULL</code></pre>
<p>Como se puede ver en los argumentos, es necesario darle la tabla de <code>datos</code> y el nombre del indicador <code>indName</code> (El de la tabla <code>tbl.specs</code>) y opcional se puede dar una lista de parametros para la función del indicador <code>parm</code>, como para la función de la señal <code>sigParm</code>, si no queda los parametros que se encuentran en <code>tbl.specs</code>. Que la función este de este forma nos permite</p>
</div>
<div id="archivos" class="section level2">
<h2>Archivos</h2>
<p>Hay tres códigos los cuales contienen las distintas funciones que configuran el flujo.</p>
</div>
<div id="read_sheet" class="section level2">
<h2><code>read_sheet()</code></h2>
<p><code>read_sheet()</code> is the main “read” function and should evoke <code>readr::read_csv()</code> and <code>readxl::read_excel()</code>. It’s an alias for <code>sheets_read()</code>. Most functions in googlesheets4 actually start with <code>sheets_</code>. googlesheets4 is pipe-friendly (and reexports <code>%&gt;%</code>), but works just fine without the pipe.</p>
<p>purrr enhances R’s functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors. If you’ve never heard of FP before, the best place to start is the family of <code>map()</code> functions which allow you to replace many for loops with code that is both more succinct and easier to read. The best place to learn about the <code>map()</code> functions is the <a href="http://r4ds.had.co.nz/iteration.html">iteration chapter</a> in R for data science.</p>
</div>
<div id="installation" class="section level2">
<h2>Installation</h2>
<pre class="r"><code># The easiest way to get purrr is to install the whole tidyverse:
install.packages(&quot;tidyverse&quot;)
# Alternatively, install just purrr:
install.packages(&quot;purrr&quot;)
# Or the the development version from GitHub:
# install.packages(&quot;devtools&quot;)
devtools::install_github(&quot;tidyverse/purrr&quot;)</code></pre>
</div>
<div id="cheatsheet" class="section level2">
<h2>Cheatsheet</h2>
<!---
<a href="https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf"><img src="https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png" width="630" height="252"/></a>  
-->
</div>
<div id="usage" class="section level2">
<h2>Usage</h2>
<p>The following example uses purrr to solve a fairly realistic problem: split a data frame into pieces, fit a model to each piece, compute the summary, then extract the R<sup>2</sup>.</p>
<pre class="r"><code>library(purrr)
mtcars %&gt;%
  split(.$cyl) %&gt;% # from base R
  map(~ lm(mpg ~ wt, data = .)) %&gt;%
  map(summary) %&gt;%
  map_dbl(&quot;r.squared&quot;)</code></pre>
<pre><code>##         4         6         8 
## 0.5086326 0.4645102 0.4229655</code></pre>
<p>This example illustrates some of the advantages of purrr functions over the equivalents in base R:</p>
<ul>
<li><p>The first argument is always the data, so purrr works naturally with the pipe.</p></li>
<li><p>All purrr functions are type-stable. They always return the advertised output type (<code>map()</code> returns lists; <code>map_dbl()</code> returns double vectors), or they throw an error.</p></li>
<li><p>All <code>map()</code> functions either accept function, formulas (used for succinctly generating anonymous functions), a character vector (used to extract components by name), or a numeric vector (used to extract by position).</p></li>
</ul>
</div>
<div id="code-of-conduct" class="section level2">
<h2>Code of conduct</h2>
<p>Please note that this project is released with a <a href="CODE_OF_CONDUCT.md">Contributor Code of Conduct</a>. By participating in this project you agree to abide by its terms.</p>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
